/*
 * main.c
 *
 *  Created on: 2017/10/26
 *      Author: M10512001
 */
#include <system.h>
#include <stdio.h>
#include <unistd.h>
#include <Altera_UP_SD_Card_Avalon_Interface.h>
#include <altera_up_avalon_video_pixel_buffer_dma.h>

#define VGA_VL 640
#define VGA_HL 480

bool SD_Card_Init(void);
void List_SD_Card_Files();
int Get_File_Len(char *filename);
char * File_Read_Into_List(char *filename, int len);
void Write_BMP_Into_SD_Card(char *list, int len);
bool Display_On_VGA(char *list, int len);

int main() {
    char filename[20];
    int len;
    char *list;
    int i;
    //alt_up_pixel_buffer_dma_dev *pixel_buf_dev = alt_up_pixel_buffer_dma_open_dev("/dev/video_pixel_buffer_dma_0");
    //if ( pixel_buf_dev == NULL)
    //	printf("Error: could not open pixel buffer device.\n");
    //else
    //	printf("Opened pixel buffer device.\n");
    //alt_up_pixel_buffer_dma_clear_screen(pixel_buf_dev, 0);
    //alt_up_pixel_buffer_dma_draw_rectangle(pixel_buf_dev, 0, 0, 319, 239, 0x001F, 0);
    while(1) {
    	while(SD_Card_Init() == false)
    		usleep(3 * 1000 * 1000);
    	printf("Info: Enter the name of the file you want to load\n");
    	scanf("%s", filename);
    	len = Get_File_Len(filename);
    	list = File_Read_Into_List(filename, len);
    	for(i=0; i<57; i++)
    		printf("%d,", list[i]);
    	printf("\n");
    	//int r,g,b,pix;
    	//b = list[54];
    	//g = list[55];
    	//r = list[56];
    	//pix = (r << 16) | (g << 8) | b;
    	//printf("%X", pix);
    	Display_On_VGA(list, len);
    	//Write_BMP_Into_SD_Card(list, len);
    	printf("\n");
    }
    return 0;
}

bool SD_Card_Init(void) {
	alt_up_sd_card_dev *sd_card_dev = alt_up_sd_card_open_dev(SD_CARD_NAME);
	if(sd_card_dev != 0) {
		if(alt_up_sd_card_is_Present()) {
			if(alt_up_sd_card_is_FAT16()) {
				printf("Info: Card is FAT16.\n");
				// 列出記憶卡根目錄下的檔案
				List_SD_Card_Files();
				return true;
			}
			else
				printf("Info: Card is not FAT16.\n");
		}
		else
			printf("Info: Please Insert the SD Card\n");
	}
	return false;
}

void List_SD_Card_Files() {
	char root_filename[20];
	printf("Info: SD Card Root List\n");
	short int first_file_result = alt_up_sd_card_find_first("/.", root_filename);
	if(first_file_result == 0) {
		printf("Info: ./%s\n", root_filename);
		while(alt_up_sd_card_find_next(root_filename) != -1)
			printf("Info: ./%s\n", root_filename);
	}
	else if(first_file_result == -1)
		printf("Info: No files were found.\n");
	else
		printf("Info: Invalid Directory or Partition is not FAT16.\n");
}

int Get_File_Len(char *filename) {
	short int sd_fileh;
	short int byte;
	int count = 0;
	// 得到檔案大小
	sd_fileh = alt_up_sd_card_fopen(filename, false);
	while(1) {
		byte = alt_up_sd_card_read(sd_fileh);
		if( byte != -1)
			count += 1;
		else
			break;
	}
	alt_up_sd_card_fclose(sd_fileh);
	printf("Info: %s is %d bytes.\n", filename, count);
	return count;
}

char * File_Read_Into_List(char *filename, int len) {
	short int sd_fileh;
	int i;
	// 依檔案大小創建動態陣列，並將檔案讀入陣列
	char *list = malloc(len * sizeof(char));
	if(!list)
		printf("Info: List create failed.\n");
	else {
		sd_fileh = alt_up_sd_card_fopen(filename, false);
		for(i=0; i<len; i++)
			list[i] = alt_up_sd_card_read(sd_fileh);
		alt_up_sd_card_fclose(sd_fileh);
	}
	// 將動態陣列的指標回傳
	return list;
}

void Write_BMP_Into_SD_Card(char *list, int len) {
	short int sd_fileh;
	int i;
	printf("Info: Save as BMP File ...");
	sd_fileh = alt_up_sd_card_fopen("save.bmp", false);
	for(i=0; i<len; i++) {
	    alt_up_sd_card_write(sd_fileh, list[i]);
	}
	alt_up_sd_card_fclose(sd_fileh);
	printf(" Done!\n");
}

bool Display_On_VGA(char *list, int len) {
	// 確認 BMP 檔是否為 24-bits 色彩
	if(list[28] == 24)
		printf("Info: It's 24-bits BMP.\n");
	else {
		printf("Info: Program only support 24bits BMP.\n");
		return false;
	}
	// 檢查 VGA 外設存在與否，並取得外設參數
	alt_up_pixel_buffer_dma_dev *pixel_buf_dev = alt_up_pixel_buffer_dma_open_dev(PIXEL_BUFFER_DMA_NAME);
	if(pixel_buf_dev == NULL)
		printf("Info: Could not open pixel buffer device.\n");
	else
		printf("Info: Pixel buffer device opened Success.\n");
	// 清空畫面
	alt_up_pixel_buffer_dma_clear_screen(pixel_buf_dev, 0);
	// 從標頭檔取得像素資料開始前的偏移量，及圖片的寬高
	int pixel_offset = list[13];
	int width = list[21], height = list[25];
	int i;
	for(i=0; i<3; i++) {
		pixel_offset = pixel_offset << 8;
		pixel_offset = pixel_offset | list[12-i];
		width = width << 8;
		width = width | list[20-i];
		height = height << 8;
		height = height | list[24-i];
	}
	printf("Info: Header and Table is %d bytes.\n", pixel_offset);
	printf("Info: %d x %d\n", width, height);
	// BMP 按列儲存，各列於列尾補 0x0(B) 至列長度為 4*n Bytes 止
	// 讀取各列時，需跳過對齊用的 Align Bytes
	int row_align = 4 - ((width * 3) % 4);
	if(row_align == 4)
		printf("Info: Row align bytes is 0.\n");
	else {
		printf("Info: Row align bytes is %d.\n", row_align);
	}
	// 設定 X, Y 座標參數，將小於解析度的圖片至中，超過解析度的圖片靠右上對齊
	int x_i = 0, x_f = VGA_VL - 1;
	int y_i = 0, y_f = VGA_HL - 1;
	if(width < VGA_VL) {
		x_i = ((VGA_VL - width) / 2) - 1;
		x_f = x_i + width;
	}
	if(height < VGA_HL) {
		y_i = ((VGA_HL - height) / 2) - 1;
		y_f = y_i + height;
	}
	// Display
	int x, y=479;
	int bp = 49206, gp = 49207, rp = 49208;
	int b, g, r, pix;
	for(y=y_f; y>=y_i; y--) {
		for(x=x_i; x<x_f; x++) {
			b = list[bp];
			g = list[gp];
			r = list[rp];
			pix = (r << 16) + (g << 8) + b;
			bp += 3;
			gp += 3;
			rp += 3;
			alt_up_pixel_buffer_dma_draw(pixel_buf_dev, pix, x ,y);
		}
	}
	printf("Info: Done!\n");
	return true;
}
